%! Author = Adam Langmesser
%! Date = 09.12.2025

\section{Zastosowanie WebSocket}
\label{sec:zastosowanie-websocket}

Niniejszy rozdział prezentuje implementację protokołu \glslink{websocket}{WebSocket} na potrzeby realizacji modułu czatu.
Opis przygotowano w oparciu o specyfikację \gls{rfc}6455 oraz dokumentację \gls{spring-framework} dotyczącą \glslink{websocket}{WebSocket} i \glslink{stomp}{STOMP}% TODO:(do zrobienia potem) dodac jesze dokuemtancje do informacj o impelemtnacji na frontendzie
\cite{rfc6455,spring-websocket,spring-stomp,sockjs-client}.

\subsection{Charakterystyka protokołu \glslink{websocket}{WebSocket}}
\label{subsec:definicja-websocket}

Na podstawie specyfikacji \gls{rfc}6455, opracowanej przez \gls{ietf}, protokół \glslink{websocket}{WebSocket} można opisać
jako mechanizm komunikacji pomiędzy aplikacją działającą w przeglądarce a \gls{serwer},
który umożliwia dwukierunkową wymianę danych w czasie zbliżonym do rzeczywistego.
Przeglądarka utrzymuje stałe połączenie z \glslink{serwer}{serwerem}, dzięki czemu może na bieżąco wysyłać dane,
a \glslink{serwer}{serwer} w dowolnym momencie przesyłać odpowiedzi, bez konieczności ciągłego odświeżania strony
ani inicjowania wielu osobnych zapytań \gls{http}. Tego typu komunikacja jest możliwa wyłącznie z \glslink{serwer}{serwerami},
które świadomie ją dopuszczają, co zwiększa kontrolę nad bezpieczeństwem.
Przeglądarka w dalszym ciągu stosuje model bezpieczeństwa oparty na pochodzeniu (origin),
weryfikując domenę, z której pochodzi kod. Technologia \glslink{websocket}{WebSocket} została zaprojektowana
z myślą o aplikacjach webowych, takich jak czaty, powiadomienia w czasie rzeczywistym,
aplikacje giełdowe czy gry sieciowe, które wymagają stałego kanału komunikacji z \glslink{serwer}{serwerem},
zamiast opierać się na wielu tradycyjnych połączeniach \gls{http} i okresowym odpytywaniu \glslink{serwer}{serwera}.

Warto podkreślić, że sam protokół \glslink{websocket}{WebSocket} definiuje przede wszystkim
\textbf{mechanizm utrzymania stałego połączenia i przesyłania \glslink{ramka}{ramek} danych}.
Nie narzuca natomiast \textbf{struktury komunikatów aplikacyjnych}, sposobu ich
adresowania, routingu ani modelu \glslink{subskrypcja}{subskrypcji}. Oznacza to, że po ustanowieniu połączenia
\glslink{websocket}{WebSocket} aplikacja musi samodzielnie ustalić, jak wygląda format wiadomości oraz w jaki sposób realizowane jest
publikowanie i odbieranie zdarzeń.

Z tego powodu często stosuje się protokoły warstwy
aplikacyjnej działające \textbf{nad} \glslink{websocket}{WebSocket}, np.\ \glslink{stomp}{STOMP}
(\emph{Simple Text Oriented Messaging Protocol}). Zapewnia on ustandaryzowaną
semantykę komunikacji w modelu wiadomościowym, w szczególności:
\begin{itemize}
    \item \textbf{adresowanie wiadomości} do tzw.\ \glslink{destynacja}{destynacji},
    \item \textbf{mechanizm \glslink{subskrypcja}{subskrypcji}} (\texttt{SUBSCRIBE}) oraz dystrybucję wiadomości w stylu \gls{publish-subscribe},
    \item \textbf{nagłówki i metadane} wiadomości (np.\ identyfikatory, typy zdarzeń, dodatkowy kontekst),
    \item \textbf{potwierdzanie odbioru} (\gls{ack}) i lepszą kontrolę nad niezawodnością dostarczenia,
    \item \textbf{obsługę błędów} na poziomie protokołu (ramki \texttt{ERROR}) oraz opcjonalne \textbf{heartbeat}
    do wykrywania zerwanych połączeń.
\end{itemize}

\subsection{Zastosowanie \glslink{websocket}{WebSocket} w naszym projekcie}
\label{subsec:zastosowanie-w-naszym-przypadku}

Główną metodą komunikacji między \glslink{backend}{backendem} a \glslink{frontend}{frontendem} w naszej aplikacji jest \gls{rest_api} oparte na protokole \gls{http}.
Tego typu interfejs bardzo dobrze sprawdza się w typowych scenariuszach,
w których \gls{klient} (\gls{frontend}) inicjuje żądanie, a \gls{serwer} (\gls{backend}) zwraca odpowiedź,
np. podczas logowania użytkownika, pobierania listy spotów czy dodawania komentarza na forum.
Każda operacja ma wówczas postać pojedynczego, niezależnego wywołania \gls{http}, po którym połączenie jest zamykane.

Problem pojawia się jednak wtedy, gdy konieczna jest ciągła wymiana danych w czasie zbliżonym do rzeczywistego,
a więc nie tylko na żądanie \glslink{klient}{klienta}, lecz także z inicjatywy \glslink{serwer}{serwera}.
W naszej aplikacji taka potrzeba wystąpiła przy implementacji modułu czatu.
Teoretycznie czat można zrealizować wyłącznie w oparciu o \gls{rest_api},
na przykład poprzez \gls{polling} – \glslink{klient}{klient} co kilka sekund wysyłałby
zapytanie o nowe wiadomości, a \glslink{serwer}{serwer} zwracałby aktualny stan konwersacji.
Można również stosować \gls{long-polling}, w którym żądanie jest utrzymywane dłużej,
aż pojawi się nowa wiadomość.

Takie podejście ma jednak istotne wady. Częste odpytywanie \glslink{serwer}{serwera} generuje
dużą liczbę żądań \gls{http}, obciążając zarówno \glslink{serwer}{serwer}, jak i sieć, mimo
że w wielu przypadkach odpowiedzi nie zawierają żadnych nowych danych.
Dodatkowo wprowadza to opóźnienia – użytkownik zobaczy nową wiadomość dopiero przy kolejnym odpytywaniu,
a nie w momencie jej wysłania. Rozwiązania oparte na \glslink{long-polling}{long pollingu} są
z kolei bardziej złożone w implementacji i wciąż nie zapewniają tak naturalnego,
dwukierunkowego kanału komunikacji, jakiego oczekuje się od współczesnego czatu.

Z tego powodu wszędzie tam, gdzie potrzebna jest stała, dwukierunkowa komunikacja
w czasie rzeczywistym, stosuje się protokół \glslink{websocket}{WebSocket}. W naszej aplikacji został
on wykorzystany właśnie w module czatu, co pozwala na utrzymanie jednego,
trwałego połączenia pomiędzy \glslink{klient}{klientem} a \glslink{serwer}{serwerem} i natychmiastowe dostarczanie
wiadomości do wszystkich uczestników konwersacji, bez konieczności ciągłego odpytywania \glslink{serwer}{serwera} za pomocą \gls{rest_api}.

\subsection{Implementacja na \gls{backend}zie}
\label{subsec:implementacja-na-backendzie}

\gls{spring-framework} udostępnia dwa popularne podejścia do obsługi komunikacji \glslink{websocket}{WebSocket}.
Pierwsze to praca na „surowych” \glslink{ramka}{ramkach} \glslink{websocket}{WebSocket} (pełna kontrola, ale konieczność
zaprojektowania własnego formatu komunikatów i dystrybucji).
Drugie wykorzystuje protokół \glslink{stomp}{STOMP} jako warstwę aplikacyjną nad \glslink{websocket}{WebSocket}.
W niniejszym projekcie wybrano wariant z \glslink{stomp}{STOMP}, ponieważ upraszcza on implementację czatu:
pozwala korzystać z gotowych \glslink{destynacja}{destynacji} (ścieżek), \glslink{subskrypcja}{subskrypcji} oraz mechanizmu publikowania wiadomości.

\subsubsection{Konfiguracja WebSocket}
\label{subsubsec:ws-config-backend}

Na rysunku \ref{img:web-socket-config-backend} przedstawiono konfigurację \glslink{websocket}{WebSocket}.
Definiuje ona \gls{endpoint} do zestawienia połączenia oraz dwa \glslink{prefiks}{prefiksy} \glslink{destynacja}{destynacji}:
dla wiadomości przychodzących do aplikacji oraz dla wiadomości rozsyłanych do \glslink{klient}{klientów}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-websocket/websocket-config}
    \caption{Konfiguracja WebSocket w module czatu (plik \texttt{WebSocketConfig.java}).}
    \label{img:web-socket-config-backend}
\end{figure}

Najważniejsze elementy konfiguracji:
\begin{itemize}
    \item \texttt{/connect} -- \gls{endpoint} zestawienia połączenia (tzw.\ \gls{handshake}); dodatkowo włączono \gls{sockjs}.
    \item \texttt{/app/*} -- \glslink{prefiks}{prefiks} \glslink{destynacja}{destynacji} dla wiadomości wysyłanych \textbf{od \glslink{klient}{klienta} do \glslink{serwer}{serwera}}
    (obsługiwanych przez metody z \texttt{@MessageMapping}).
    \item \texttt{/subscribe/*} -- \glslink{prefiks}{prefiks} \glslink{destynacja}{destynacji} dla wiadomości wysyłanych \textbf{od \glslink{serwer}{serwera} do \glslink{klient}{klientów}}
    (\glslink{klient}{klient} \glslink{subskrypcja}{subskrybuje} te kanały, a \glslink{serwer}{serwer} publikuje tam komunikaty).
    \item \texttt{SecurityContextChannelInterceptor} -- zapewnia dostęp do kontekstu bezpieczeństwa dla wiadomości przychodzących
    (backend rozpoznaje, kto wysłał wiadomość).
\end{itemize}

\subsubsection{Kontroler przyjmujący wiadomości od \glslink{klient}{klienta}}
\label{subsubsec:ws-controller-backend}

Rysunek \ref{img:web-socket-controller-backend} pokazuje kontroler \glslink{stomp}{STOMP}, który jest punktem wejścia
dla nowych wiadomości wysyłanych przez użytkownika.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-websocket/stomp-controller-backend}
    \caption{Kontroler \glslink{stomp}{STOMP} odbierający wiadomości czatu (plik \texttt{ChatStompCommunicationController.java}).}
    \label{img:web-socket-controller-backend}
\end{figure}

Kontroler udostępnia wejściową \glslink{destynacja}{destynację}: \texttt{/app/send/\{chatId\}/message}.
Jej rola jest następująca:
\begin{enumerate}
    \item odebrać wiadomość od \glslink{klient}{klienta},
    \item zlecić zapis wiadomości do \gls{baza-danych} (serwis domenowy czatu),
    \item uruchomić rozesłanie wiadomości,
    \item oddelegować wysłanie potwierdzenia (\gls{ack}) do nadawcy wiadomości.
\end{enumerate}

\subsubsection{Serwis dystrybucji wiadomości}
\label{subsubsec:ws-service-backend}

Rysunek \ref{img:web-socket-serwis-backend} przedstawia serwis, który odpowiada za publikowanie komunikatów
na kanały \glslink{subskrypcja}{subskrypcji} \texttt{/subscribe/*}. Serwis ten jest wykorzystywany zarówno przez kontroler \glslink{stomp}{STOMP},
jak i przez inne elementy logiki modułu czatu.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-websocket/stomp-serwis}
    \caption{Serwis rozsyłający wiadomości czatu i potwierdzenia \gls{ack} (plik \texttt{ChatStompCommunicationService.java}).}
    \label{img:web-socket-serwis-backend}
\end{figure}

Serwis realizuje dwa typy wysyłki:
\begin{itemize}
    \item \textbf{Broadcast wiadomości do uczestników czatu} -- po zapisaniu wiadomości \glslink{serwer}{serwer} pobiera listę uczestników czatu
    i wysyła \texttt{ChatMessageDto} do każdego z nich na jego kanał użytkownika.
    \item \textbf{\gls{ack} do nadawcy} -- \glslink{serwer}{serwer} wysyła potwierdzenie \texttt{ChatMessageAckDto} na osobny kanał nadawcy,
    aby \gls{frontend} mógł powiązać wiadomość zapisaną w \gls{baza-danych} z odpowiadającą jej wersją „optymistyczną”.
\end{itemize}

\subsubsection{Zestawienie wykorzystywanych \glslink{destynacja}{destynacji}}
\label{subsubsec:ws-destynacje-backend}

Poniżej zestawiono wszystkie \glslink{destynacja}{destynacje} (ścieżki) używane w komunikacji \glslink{websocket}{WebSocket} w module czatu:

\begin{description}
    \item[\texttt{/connect}] \gls{endpoint} zestawienia połączenia \glslink{websocket}{WebSocket} (tzw.\ \gls{handshake}).
    \item[\texttt{/app/send/\{chatId\}/message}] Wejście do backendu: \glslink{klient}{klient} wysyła nową wiadomość do czatu o identyfikatorze \texttt{chatId}.
    \item[\texttt{/subscribe/chats/\{username\}}] Kanał użytkownika: \glslink{klient}{klient} \glslink{subskrypcja}{subskrybuje} i odbiera nowe wiadomości (ze wszystkich czatów, w których uczestniczy).
    \item[\texttt{/subscribe/chats/ack/\{username\}}] Kanał potwierdzeń (\gls{ack}): \glslink{klient}{klient} (nadawca) odbiera potwierdzenie zapisania wiadomości.
\end{description}

Dodatkowo stosowane są dwa \glslink{prefiks}{prefiksy} porządkujące komunikację:
\begin{itemize}
    \item \texttt{/app/*} -- wiadomości od \glslink{klient}{klienta} do aplikacji,
    \item \texttt{/subscribe/*} -- wiadomości od aplikacji do \glslink{klient}{klientów} (kanały \glslink{subskrypcja}{subskrypcji}).
\end{itemize}

\subsection{Implementacja na \gls{frontend}zie}
\label{subsec:implementacja-na-frontendzie}
folder stomp

\subsection{Przebieg komunikacji}
\label{subsec:przebieg-komunikacji}

[diagram]

1. odniesienia do slwoniczka
2. odniesienia do bibliografii
