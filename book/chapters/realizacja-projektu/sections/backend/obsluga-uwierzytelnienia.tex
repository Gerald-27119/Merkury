%! Author = Adam
%! Date = 23/12/2025

\subsection{Bezpieczeństwo aplikacji}
\label{subsec:bezpieczenstwo-aplikacji}

%1. Po co uzylismy spring security
%2. czym jest spring security
%https://docs.spring.io/spring-security/reference/index.html
%
%diagramy filtry: https://docs.spring.io/spring-security/reference/servlet/architecture.html
%
%JwtProperties
%UrlsProperties
%JwtConfig
%SecuritCOnfig
%
%folder security
%
%diagram ze springa jak dziala security? odwolania do chain of responsibility
%diagram jak sie ansze te wpisuaj w to

Niniejszy rozdział prezentuje implementację zabezpieczeń aplikacji na backendzie.
Rozdział przygotowano w oparciu o podane źródła:
\begin{itemize}
    \item https://docs.spring.io/spring-security/reference/index.html.
    \item https://docs.spring.io/spring-security/reference/servlet/architecture.html.
\end{itemize}


Podczas tworzenia aplikacji webowej opartej o serwer zapewniający \gls{api}
kwestie bezpieczeństwa są jednym z kluczowych aspektów projektowych.
Wystawienie usług do sieci oznacza, że system jest stale narażony na próby
nieautoryzowanego dostępu, nadużycia mechanizmów logowania, a także ataki
prowadzące do ujawnienia lub modyfikacji danych.
Brak odpowiednich zabezpieczeń może skutkować przejęciem kont użytkowników,
wyciekiem informacji lub wykorzystaniem zasobów systemu
w sposób niezgodny z przeznaczeniem.


Na bezpieczeństwo aplikacji składają się przede wszystkim następujące obszary:

\begin{itemize}
    \item \textbf{Uwierzytelnianie} -- proces potwierdzania tożsamości klienta
    komunikującego się z systemem. Oznacza to zapewnienie, że żądanie
    pochodzi od konkretnego, znanego użytkownika.

    \item \textbf{Autoryzacja} -- określenie i przestrzeganie polityki dostępu oraz operacji na zasobach,
    do jakich dostęp ma uwierzytelniony użytkownik.
    Nawet poprawnie uwierzytelniony klient
    nie powinien mieć możliwości wykonania akcji, do których nie posiada uprawnień.

    \item \textbf{Ochrona przed typowymi atakami} -- zestaw mechanizmów, które mają
    na celu ograniczenie ryzyka podatności i nadużyć, takich jak ataki typu brute-force,
    nieprawidłowa konfiguracja \gls{cors}, czy wykorzystanie luk
    w warstwie aplikacyjnej. Istotne są również bezpieczne nagłówki HTTP,
    poprawna obsługa błędów oraz kontrola sposobu przetwarzania danych wejściowych.

    \item \textbf{Integralność i poufność komunikacji} -- zapewnienie, że dane przesyłane
    pomiędzy klientem a serwerem nie mogą zostać łatwo podejrzane lub zmodyfikowane
    po drodze. W kontekście aplikacji internetowych sprowadza się to głównie do
    stosowania szyfrowania transportowego (HTTPS/TLS) oraz konsekwentnego egzekwowania
    polityk bezpieczeństwa w warstwie serwera.
\end{itemize}

W projekcie wykorzystano ekosystem Spring Boot, który zapewnia gotową integrację
mechanizmów bezpieczeństwa w ramach Spring Security.

\subsubsection{Spring Security}
\label{subsubsec:spring-security}

Spring Security jest frameworkiem dostarczanym w ramach ekosystemu Spring'a,
który można dołączyć do projektu jako zależność.
Jego zadaniem jest zapewnienie kompletnego zestawu mechanizmów związanych z bezpieczeństwem
warstwy serwerowej: od uwierzytelniania i autoryzacji, po ochronę przed najczęściej
spotykanymi zagrożeniami w aplikacjach webowych.

Istotną cechą Spring Security jest oparcie działania o łańcuch filtrów,
przez który przechodzi każde żądanie HTTP trafiające do aplikacji.
Twórcy frameworka skorzystali w tym celu ze wzorca [TODO: odniesienie do opisu CoR]. %TODO: uzupelnic potem, jak wzorzec bedze opisany
Dzięki temu możliwe jest przechwycenie żądania na wczesnym etapie,
zbudowanie kontekstu bezpieczeństwa oraz podjęcie decyzji,
czy żądanie może zostać przekazane dalej.
Oznacza to, że kontrola dostępu jest realizowana konsekwentnie i centralnie,
bez konieczności ręcznego powielania sprawdzeń w wielu miejscach kodu.

\subsubsection{Konfiguracja Spring Security}
\label{subsubsec:konfiguracja-spring-security}
%TODO: za male zdjecia
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-backendu/security/SecurityConfig/1}
    \caption{Konfigureacja security (1/4)}
    \label{fig:security-config-1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-backendu/security/SecurityConfig/2}
    \caption{Konfigureacja security (2/4)}
    \label{fig:security-config-2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-backendu/security/SecurityConfig/3}
    \caption{Konfigureacja security (3/4)}
    \label{fig:security-config-3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{attachments/implementacja-backendu/security/SecurityConfig/4}
    \caption{Konfigureacja security (4/4)}
    \label{fig:security-config-4}
\end{figure}

W niniejszej sekcji opisano konfigurację zabezpieczeń po stronie backendu,
zrealizowaną w pliku \texttt{SecurityConfig}. Konfiguracja bazuje na \gls{spring-security}
i definiuje sposób obsługi uwierzytelniania oraz autoryzacji dla \gls{api}.
Zastosowano podejście rozdzielające ruch na:
(1) ścieżki publiczne, dostępne bez logowania,
oraz (2) ścieżki prywatne, wymagające poprawnego uwierzytelnienia.

\subsection{Adnotacje i rola klasy konfiguracyjnej}
\label{subsec:adnotacje-security-config}

Klasa \texttt{SecurityConfig} jest oznaczona adnotacjami:
\begin{itemize}
    \item \texttt{@Configuration} -- wskazuje, że klasa dostarcza definicje bean'a dla kontenera Spring.
    \item \texttt{@EnableWebSecurity} -- aktywuje mechanizmy bezpieczeństwa na poziomie aplikacji webowej.
    \item \texttt{@EnableMethodSecurity} -- umożliwia zabezpieczanie logiki na poziomie metod
    (np.\ przez adnotacje typu \texttt{@PreAuthorize}).
    \item \texttt{@RequiredArgsConstructor} -- wstrzykuje zależności poprzez konstruktor
    (m.in.\ \texttt{UrlsProperties} oraz \texttt{CustomUserDetailsService}).
\end{itemize}

\subsection{Podział ruchu na ścieżki publiczne i prywatne}
\label{subsec:podzial-sciezek-public-private}

Konfiguracja wykorzystuje dwa obiekty typu \texttt{RequestMatcher}:
\begin{itemize}
    \item \texttt{publicPathsMatcher} -- złożony matcher (\texttt{OrRequestMatcher}) wskazujący ścieżki publiczne,
    m.in.\ \texttt{/public/**}, \texttt{/login/**}, \texttt{/oauth2/**}, \texttt{/error} oraz \texttt{/actuator/**}.
    \item \texttt{privatePathsMatcher} -- negacja matchera publicznego (\texttt{NegatedRequestMatcher}),
    czyli „wszystko poza ścieżkami publicznymi”.
\end{itemize}

Takie podejście pozwala stosować różne zasady bezpieczeństwa dla różnych obszarów aplikacji
bez mieszania reguł w jednym, trudnym do utrzymania łańcuchu filtrów.

\subsection{Dwa niezależne łańcuchy filtrów Spring Security}
\label{subsec:dwa-lancuchy-security-filter-chain}

W pliku zdefiniowano dwa \texttt{SecurityFilterChain} z różnymi priorytetami (\texttt{@Order}),
które są wybierane na podstawie dopasowania \texttt{securityMatcher(...)}.

\subsubsection{Łańcuch dla ścieżek publicznych}
\label{subsubsec:public-security-filter-chain}

Bean \texttt{publicSecurityFilterChain} (z \texttt{@Order(1)}) obsługuje wyłącznie żądania
pasujące do \texttt{publicPathsMatcher}. Jego główne cechy:
\begin{itemize}
    \item \textbf{Brak wymogu uwierzytelnienia}:
    \texttt{authorizeHttpRequests().anyRequest().permitAll()} dopuszcza każde żądanie w tej przestrzeni URL.
    \item \textbf{Konfiguracja CORS}:
    poprzez \texttt{cors(...)} i \texttt{corsConfigurationSource()} dopuszcza komunikację z wybranych originów
    (szczególnie istotne dla \gls{frontend} uruchamianego na innym porcie).
    \item \textbf{Wyłączenie CSRF}:
    \texttt{csrf().disable()} upraszcza obsługę wywołań \gls{api} wykonywanych przez klienta (np.\ SPA),
    gdzie typowo stosuje się tokeny w nagłówkach zamiast klasycznych formularzy.
    \item \textbf{Obsługa OAuth2 logowania}:
    \texttt{oauth2Login(...)} definiuje stronę logowania oraz adresy przekierowań po sukcesie i porażce,
    pobierane z \texttt{UrlsProperties}.
    \item \textbf{Logout dla sesji OAuth2}:
    \texttt{logout(...)} ustawia dedykowany URL wylogowania (\texttt{/account/oauth2/logout}),
    czyści kontekst bezpieczeństwa, unieważnia sesję oraz usuwa cookie zawierające token
    (nazwa cookie pochodzi z \texttt{JwtProperties}).
    \item \textbf{Zarządzanie sesją}:
    \texttt{SessionCreationPolicy.IF\_REQUIRED} oznacza, że sesja jest tworzona tylko wtedy, gdy jest potrzebna
    (np.\ w scenariuszu logowania OAuth2).
    \item \textbf{Wyłączenie HTTP Basic}:
    \texttt{httpBasic().disable()} zapobiega używaniu mechanizmu Basic Auth.
\end{itemize}

W praktyce ten łańcuch pełni rolę „bramy” dla endpointów, które muszą pozostać dostępne bez logowania
(np.\ zasoby publiczne, obsługa procesu OAuth2, endpointy pomocnicze).

\subsubsection{Łańcuch dla ścieżek prywatnych}
\label{subsubsec:private-security-filter-chain}

Bean \texttt{privateSecurityFilterChain} (z \texttt{@Order(2)}) dotyczy wszystkich pozostałych żądań,
czyli tych dopasowanych do \texttt{privatePathsMatcher}. Najważniejsze elementy:
\begin{itemize}
    \item \textbf{Wymóg uwierzytelnienia}:
    \texttt{authorizeHttpRequests().anyRequest().authenticated()} wymusza, aby każde żądanie
    zostało poprawnie rozpoznane jako pochodzące od zalogowanego użytkownika.
    \item \textbf{Własna obsługa odmowy dostępu}:
    \texttt{exceptionHandling().accessDeniedHandler(customAccessDeniedHandler)}
    zapewnia spójny format odpowiedzi (np.\ jednolitą strukturę błędu) przy braku uprawnień.
    \item \textbf{Filtr JWT wpięty w łańcuch}:
    \texttt{addFilterBefore(jwtAuthFilter, LogoutFilter.class)} powoduje, że token jest weryfikowany
    zanim przetwarzanie dojdzie do dalszych elementów security.
    W efekcie kontekst bezpieczeństwa może zostać zbudowany na podstawie tokenu,
    a autoryzacja może działać dla wszystkich endpointów prywatnych.
    \item \textbf{CORS i CSRF}:
    podobnie jak w części publicznej włączono CORS i wyłączono CSRF.
    \item \textbf{Zarządzanie sesją}:
    pozostawiono \texttt{SessionCreationPolicy.IF\_REQUIRED}; w praktyce pozwala to łączyć podejście tokenowe
    z obszarami, które ewentualnie wymagają sesji (np.\ przepływy logowania).
    \item \textbf{Wyłączenie HTTP Basic}:
    analogicznie jak wyżej, aby nie dopuszczać alternatywnej metody uwierzytelniania.
\end{itemize}

\subsection{Konfiguracja CORS}
\label{subsec:cors-config}

Metoda \texttt{corsConfigurationSource()} definiuje politykę \gls{cors} dla całej aplikacji (\texttt{/**}):
\begin{itemize}
    \item dozwolone originy: \texttt{http://localhost:5173} oraz \texttt{http://localhost:5174},
    \item dozwolone metody: \texttt{GET, POST, PUT, DELETE, OPTIONS, PATCH},
    \item dozwolone nagłówki: m.in.\ \texttt{Authorization} oraz \texttt{Content-Type},
    \item \texttt{allowCredentials = true} -- dopuszcza wysyłanie cookies/poświadczeń w zapytaniach,
    \item \texttt{maxAge = 3600} -- cache polityki CORS po stronie przeglądarki.
\end{itemize}

\subsection{Pozostałe beany: uwierzytelnianie i elementy JWT}
\label{subsec:beany-auth-jwt}

W konfiguracji zdefiniowano dodatkowe komponenty wymagane przez warstwę security:
\begin{itemize}
    \item \texttt{AuthenticationManager} -- pobierany z \texttt{AuthenticationConfiguration};
    umożliwia uruchamianie procesu uwierzytelniania w sposób zgodny z konfiguracją Spring Security.
    \item \texttt{PasswordEncoder} -- zastosowano \texttt{BCryptPasswordEncoder},
    czyli bezpieczny mechanizm haszowania haseł.
    \item \texttt{JwtAuthFilter} -- tworzony jako bean wraz z zależnościami
    (\texttt{JwtGenerator}, \texttt{JwtManager}, \texttt{JwtProperties}, \texttt{CustomUserDetailsService}).
    Filtr odpowiada za odczyt tokenu z żądania, jego walidację oraz ustawienie kontekstu bezpieczeństwa.
\end{itemize}

\subsection{Wyłączenie rejestracji filtra przez kontener servletów}
\label{subsec:disable-filter-registration}

Na końcu zdefiniowano:
\texttt{FilterRegistrationBean<JwtAuthFilter>} z \texttt{setEnabled(false)}.
Celem jest wyłączenie automatycznej rejestracji filtra przez warstwę servletową,
ponieważ filtr JWT jest dodawany ręcznie do właściwego \texttt{SecurityFilterChain}.
Zapobiega to sytuacji, w której ten sam filtr wykonałby się podwójnie (raz jako filtr security,
a drugi raz jako filtr globalny aplikacji).






%diagram 1
%daigram 2
